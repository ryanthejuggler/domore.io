// Generated by CoffeeScript 1.6.3
(function() {
  var DatePattern, ObjectID, Task, db, hashtagPattern,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  db = require('./Db');

  ObjectID = db.ObjectID;

  DatePattern = require('./DatePattern');

  hashtagPattern = /#\w+/g;

  /*
    @class Task
  */


  Task = (function() {
    /**
      @field _id {ObjectID}
      @field owner {ObjectID}
      @field title {string}
      @field description {string}
      @field hashtags {Array(String)}
      @field start {Date or "none"} datetime when this event starts or task can start
      @field end {Date or "none"} datetime when this event ends or task is due
      @field type {string} Either 'event' or 'task'
      @field blockedBy {Array(ObjectID)} List of ObjectIDs for tasks that are blocking this one
      @field blockerFor List of ObjectIDs for tasks that this one is blocking
      @field status {String} one of (blocked|ready|inprogress|complete)
      @field recurs {undefined or DatePattern} if this task recurs, the DatePattern that
          describes the repetition of this task
      @field recurring {undefined or Task} if this is an instance of a recurring task,
          the first task in the set
    */

    /**
      @constructor
    */

    function Task(config) {
      this._id = config._id, this.owner = config.owner, this.title = config.title, this.description = config.description, this.hashtags = config.hashtags;
      this.start = config.start, this.end = config.end, this.type = config.type, this.blockedBy = config.blockedBy, this.blockerFor = config.blockerFor, this.status = config.status;
      if (this.title == null) {
        this.title = '';
      }
      if (this.description == null) {
        this.description = '';
      }
      if (this.start == null) {
        this.start = 'none';
      }
      if (this.end == null) {
        this.end = 'none';
      }
      if (this.type == null) {
        this.type = 'event';
      }
      if (this.blockedBy == null) {
        this.blockedBy = [];
      }
      if (this.blockerFor == null) {
        this.blockerFor = [];
      }
      if (this.status == null) {
        this.status = 'ready';
      }
      if (this.hashtags == null) {
        this.hashtags = [];
      }
      if (config.recurs != null) {
        this.recurs = config.recurs;
        this.recurs = new DatePattern(this.recurs);
      }
      if (config.recurring != null) {
        this.recurring = config.recurring;
      }
    }

    Task.prototype.pickle = function() {
      var taskData, _ref, _ref1, _ref2, _ref3, _ref4;
      taskData = {
        owner: this.owner,
        title: (_ref = this.title) != null ? _ref : '',
        description: (_ref1 = this.description) != null ? _ref1 : '',
        start: (_ref2 = this.start) != null ? _ref2 : 'none',
        end: (_ref3 = this.end) != null ? _ref3 : 'none',
        type: (_ref4 = this.type) != null ? _ref4 : 'event',
        blockedBy: this.blockedBy,
        blockerFor: this.blockerFor,
        status: this.status,
        hashtags: this.hashtags
      };
      if (this._id) {
        taskData._id = this._id;
      }
      if (this.recurs) {
        taskData.recurs = this.recurs;
      }
      return taskData;
    };

    Task.prototype.process = function() {
      var newTags, tag, _i, _j, _len, _len1, _results;
      newTags = this.title.match(hashtagPattern);
      if (newTags) {
        for (_i = 0, _len = newTags.length; _i < _len; _i++) {
          tag = newTags[_i];
          tag = tag.replace(/^#/, '');
          if (__indexOf.call(this.hashtags, tag) < 0) {
            this.hashtags.push(tag);
          }
        }
      }
      newTags = this.description.match(hashtagPattern);
      if (newTags) {
        _results = [];
        for (_j = 0, _len1 = newTags.length; _j < _len1; _j++) {
          tag = newTags[_j];
          tag = tag.replace(/^#/, '');
          if (__indexOf.call(this.hashtags, tag) < 0) {
            _results.push(this.hashtags.push(tag));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    /**
      @method save
    */


    Task.prototype.save = function(callback) {
      var taskData;
      taskData = this.pickle();
      return db.collection('tasks', function(err, cxn) {
        return cxn.save(taskData, {
          safe: true
        }, function(err) {
          return callback(err);
        });
      });
    };

    Task.prototype.del = function(callback) {
      var _this = this;
      return db.collection('tasks', function(err, cxn) {
        return cxn.remove({
          _id: _this._id
        }, {
          safe: true
        }, function(err, result) {
          return callback(err);
        });
      });
    };

    return Task;

  })();

  Task.getAllPicklesForUser = function(user, callback) {
    return db.collection('tasks', function(err, cxn) {
      return cxn.find({
        owner: user._id
      }).sort({
        start: 1
      }).toArray(function(err, docs) {
        var snippets;
        if (err) {
          callback(err);
        }
        snippets = docs;
        return callback(null, snippets);
      });
    });
  };

  Task.getAllForUser = function(user, callback) {
    return Task.getAllPicklesForUser(user, function(err, docs) {
      var doc, tasks;
      if (err) {
        callback(err);
      }
      tasks = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = docs.length; _i < _len; _i++) {
          doc = docs[_i];
          _results.push(new Task(doc));
        }
        return _results;
      })();
      return callback(null, tasks);
    });
  };

  Task.getByUserAndId = function(user, id, callback) {
    id = new ObjectID(id);
    return db.collection('tasks', function(err, cxn) {
      return cxn.find({
        owner: user._id,
        _id: id
      }).toArray(function(err, docs) {
        var snippet;
        if (err) {
          callback(err);
        }
        if (docs.length === 0) {
          callback('no such animal');
        }
        snippet = docs[0];
        snippet = new Task(snippet);
        return callback(null, snippet);
      });
    });
  };

  module.exports = Task;

}).call(this);
